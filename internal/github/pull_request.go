package github

import (
	"context"
	"errors"
	"fmt"
	"net/url"
	"strings"
	"time"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/config"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/transport"
	"github.com/go-git/go-git/v5/plumbing/transport/http"
	"github.com/google/go-github/v72/github"
	"golang.org/x/oauth2"
)

var PRTitle = `Reflexia autodoc`
var PRBody = `This commit is autogenerated using Reflexia.`

const CommitMessage = `Reflexia autodoc`
const CommitName = `Reflexia`
const CommitEmail = `reflexia@swarmind.ai`

const BranchFormat = `%s_autodoc`

func CreatePR(
	ctx context.Context,
	repo *git.Repository,
	branch,
	githubUsername,
	githubToken string,
) (string, error) {
	autodocBranch := fmt.Sprintf(BranchFormat, branch)

	remote, err := repo.Remote("origin")
	if err != nil {
		return "", fmt.Errorf("get remote: %w", err)
	}

	err = commit(repo, autodocBranch, githubUsername, githubToken)
	if err != nil && !errors.Is(err, git.ErrEmptyCommit) {
		return "", fmt.Errorf("commit: %w", err)
	}

	repoURL := remote.Config().URLs[0]
	u, err := url.ParseRequestURI(repoURL)
	if err != nil {
		return "", fmt.Errorf("parsing remote[0] repo url: %w", err)
	}

	if u.Host != "github.com" {
		return "", fmt.Errorf("only github.com repo url is supported for PR creation")
	}

	sPath := strings.Split(strings.TrimPrefix(u.Path, "/"), "/")
	if len(sPath) < 2 {
		return "", fmt.Errorf("github repo url should have at least two elements in path")
	}
	githubOwner := sPath[0]
	githubRepo := sPath[1]

	client := github.NewClient(
		oauth2.NewClient(ctx,
			oauth2.StaticTokenSource(
				&oauth2.Token{AccessToken: githubToken},
			),
		),
	)

	prs, _, err := client.PullRequests.List(ctx, githubOwner, githubRepo, &github.PullRequestListOptions{
		Head:  fmt.Sprintf("%s:%s", githubOwner, autodocBranch),
		Base:  branch,
		State: "open",
	})
	if len(prs) > 0 {
		return prs[0].GetHTMLURL(), nil
	}

	pr, _, err := client.PullRequests.Create(ctx, githubOwner, githubRepo,
		&github.NewPullRequest{
			Title: &PRTitle,
			Head:  &autodocBranch,
			Base:  &branch,
			Body:  &PRBody,
		},
	)
	if err != nil {
		return "", fmt.Errorf("creating pull request: %w", err)
	}

	return pr.GetHTMLURL(), nil
}

func commit(
	repo *git.Repository,
	autodocBranch string,
	githubUsername,
	githubToken string,
) error {
	w, err := repo.Worktree()
	if err != nil {
		return fmt.Errorf("get worktree: %w", err)
	}

	autodocBranchRefName := plumbing.ReferenceName(fmt.Sprintf("refs/heads/%s", autodocBranch))

	_, err = w.Add(".")
	if err != nil {
		return fmt.Errorf("stage changes: %w", err)
	}

	_, err = w.Commit(CommitMessage, &git.CommitOptions{
		Author: &object.Signature{
			Name:  CommitName,
			Email: CommitEmail,
			When:  time.Now(),
		},
	})
	if err != nil {
		return fmt.Errorf("commit: %w", err)
	}

	remote, err := repo.Remote("origin")
	if err != nil {
		return fmt.Errorf("get remote: %w", err)
	}

	if len(remote.Config().URLs) == 0 {
		return fmt.Errorf("empty remote urls")
	}

	var auth transport.AuthMethod
	if githubUsername != "" && githubToken != "" {
		auth = &http.BasicAuth{
			Username: githubUsername,
			Password: githubToken,
		}
	}

	err = remote.Push(&git.PushOptions{
		RemoteName: "origin",
		RefSpecs: []config.RefSpec{
			config.RefSpec(fmt.Sprintf("%s:%s", autodocBranchRefName, autodocBranchRefName)),
		},
		Auth:  auth,
		Force: true,
	})
	if err != nil {
		return fmt.Errorf("push: %w", err)
	}

	return nil
}
