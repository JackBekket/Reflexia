file_filter = [".py"]
project_root_filter = ["pyproject.toml"] # TODO: bug, ["requirements.txt","pyproject.toml"] cannot determine python lang
module_match = "package_name"
stop_words = ["<end_of_output>"]
# this prompt is called first and go through files content. This prompt is called separately for each file content.
#
code_prompt = """
Your task is to describe the provided code (file content) which may or may not be part of a package or component
First you need to write the package name and collect all the imports.
Then you need to collect and describe all the external data, input sources.
Don't forget to describe cmdline arguments and flags if they present.
You can create any section for that purpose if you need to.
After that you need to describe each code symbol, reducting your output, but trying not to lose the details and original namings.
It is mandatory to prepend the <end_of_output> at the very end of your output.


Provided code:
"""

# deprecated (?)
summary_prompt = """
Based on provided input from summary of the project files create a markdown summary of what that project code does.
First write a short summary about provided project code summary.
Always list and specify environment variables, flags, cmdline arguments, files and their paths that can be used for configuration if they.
Always list and specify the edgecases of how application can be launched.
Try to guess the project name from the filenames if possible and add it as the markdown header of the summary.
Then write summary about every major code part, group it with the markdown subheaders.
Try to explain relations between code entities, try to find unclear places, possibly dead code.		
If unclear places or dead code are not present - don't write anything about their absense.
Try to be clear, concise, and brief.
The main goal is to summarize the logic of the whole project.
It is mandatory to prepend the <end_of_output> at the very end of your output.
"""

# this prompt takes all content generated to files and maka a summary for a package, therefore group code generatation output by package name. It is second call from main loop
package_prompt = """
Based on provided input from the summary of project package files create a markdown summary of what that package code does.
First write a short summary about provided files code summary.
Always list and specify environment variables, flags, cmdline arguments, files and their paths that can be used for configuration if they present.
Always list and specify the edgecases of how application can be launched if it is cmd/cli/main package.
Try to guess package name from the file contents or file paths and add it as the markdown header of the summary.
Write out all file names as a project package structure.
Try to explain relations between code entities, try to find unclear places, possibly dead code.		
If unclear places or dead code are not present - don't write anything about their absense.
Try to be clear, concise, and brief.
The main goal is to summarize the logic of the whole package.
It is mandatory to prepend the <end_of_output> at the very end of your output.
"""

legacy_package_prompt = """
Based on provided input from the summary of project package files create a markdown summary of what that package code does.
First write a short summary about provided files code summary.
Always list and specify environment variables, flags, cmdline arguments, files and their paths that can be used for configuration if they present.
Always list and specify the edgecases of how application can be launched if it is cmd/cli/main package.
Try to guess package name from the file contents or file paths and add it as the markdown header of the summary.
Write out all file names as a project package structure.
Then write summary about every major code part, group it with the markdown subheaders.
Try to explain relations between code entities, try to find unclear places, possibly dead code.		
If unclear places or dead code are not present - don't write anything about their absense.
Try to be clear, concise, and brief.
The main goal is to summarize the logic of the whole package.
It is mandatory to prepend the <end_of_output> at the very end of your output.
"""

# deep explain
explain_code_prompt = """
Your task is to describe the provided code (file content) which may or may not be part of a package or component
First you need to write the package name and collect all the imports.
Then you need to collect and describe all the external data, input sources.
Don't forget to describe cmdline arguments and flags if they present.
You can create any section for that purpose if you need to.
After that you need to describe each code symbol, reducting your output, but trying not to lose the details and original namings.
It is mandatory to prepend the <end_of_output> at the very end of your output.


Provided code:
"""


#summarize -- this is not just a summarization but attempt to write chunk of documentation
code_summary_prompt = """
Your task is to summarize the provided code (file content) which could be part of a package or other component.
As a result you would have a summarized info about provided part of code within one package/component, and this result will be used to create summary about whole package
First you need to write the package/component name and collect all the imports.
Then you need to collect and describe all the external data, input sources.
You can create any section for that purpose if you need to.
After that you need to write summary about every major code part, group it with the markdown subheaders, reducting your output, knowing that you are summarizing a file in a package and that this info will be used to create summary for a whole package
It is mandatory to prepend the <end_of_output> at the very end of your output.


Provided code:
"""